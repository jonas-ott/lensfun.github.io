<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>lensfun: How the corrections work</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    messageStyle: "none"
});
</script><script type="text/javascript" src="http://lensfun.github.io/mathjax/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="lensfun-manual.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lensfun
   &#160;<span id="projectnumber">0.3.95.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">How the corrections work </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>For both the people working on Lensfun and the people working with Lensfun, it is very important to understand how corrections are applied to the images.</p>
<h1><a class="anchor" id="ordering"></a>
Order of the image operations</h1>
<p>The image operations are not commutative. Thus, it is important to apply them in the right order. This is:</p>
<ol>
<li>
devignetting </li>
<li>
anti-TCA </li>
<li>
undistortion </li>
<li>
change of projection </li>
<li>
perspective correction </li>
<li>
scaling </li>
</ol>
<h2><a class="anchor" id="imagecorrections"></a>
Image corrections</h2>
<p>The first three image operations that are applied are the image corrections.</p>
<p>Their order relative to each other is closely connected with the way the lens errors are <em>measured</em>. Vignetting is measured on the pristine image, consequently, it must be corrected before any pixel-warping operations are applied. The same is true for TCA measurements. Distortion is also measured on the pristine image, however, undistortion is not affected by a previous devigneting or anti-TCA. This results in the above enumerated order: First devignetting, then anti-TCA, then undistortion.</p>
<p>Well, the order of devignetting and anti-TCA is still not clearly defined by this actually. But imagine very very hefty TCA. It distorts the red and the blue channel relatively to the green one. This would affect the vignetting measurement considerably. However, the other way round would be much less invasive: A massive vignetting would not change the TCA measurements much. Therefore, vignetting must be eliminated before TCA is eliminated. Otherwise, devignetting would work on the wrong image.</p>
<p>By the way, correcting TCA and distortion one directly after the other makes it possible to do this very efficiently: The pixel coordinates are transformed by both image operators, and after that, only <em>one</em> interpolation and <em>one</em> pixel value lookup are necessary.</p>
<h2><a class="anchor" id="changeofprojection"></a>
Change of projection</h2>
<p>Lensfun can also re-map a fisheye to a rectilinear image. Mathematically speaking, a perfect lens follows a well-defined projection (in other places also called “lens type” or “geometry”), like:</p>
<p class="formulaDsp">
\[\begin{aligned} r &amp;= 2f\sin(\theta/2) &amp;\text{equisolid} \\ r &amp;= f\theta &amp;\text{equidistant} \\ r &amp;= 2f\tan(\theta/2) &amp;\text{stereographic} \\ r &amp;= f\sin(\theta) &amp;\text{orthographic} \\ r &amp;= f\tan(\theta) &amp;\text{rectilinear} \end{aligned} \]
</p>
<p>Here, \(\theta\) is the angle between the incoming ray of light and the optical axis, \(f\) is the focal length, and \(r\) is the distance of the resulting dot on the sensor from the sensor center.</p>
<p>You see, the rectilinear projection is just one of many. And all of them have their advantages and disadvantages. The first four projections are considered fisheye.</p>
<p>Lensfun can change the projection of the image. But converting e.g. from fisheye to rectilinear is not a correction. A fisheye image is as perfect as a rectilinear image if it follows the respective projection formula. And the image follows the projection formula after a successful distortion correction.</p>
<p>Therefore, the change of projection is perfomed <em>after</em> the image corrections.</p>
<h2><a class="anchor" id="pc"></a>
Perspective correction</h2>
<p>Lensfun can correct the effects of tilting of the camera, also known as perspective correction, see <a class="el" href="perspective-correction.html">Applying perspective correction</a>. In order for this to work properly, the distortion needs to be corrected, and the image needs to be converted to rectilinear projection if necessary. Therefore, perspective correction is performed <em>after</em> the change of projection.</p>
<h2><a class="anchor" id="scaling"></a>
Scaling</h2>
<p>Often it is desirable to scale the resulting image, e.g. to eliminate black areas at the borders caused by one of the previous image operations. Because all other transformations assume the pristine sensor image, in particular for assuming the correct focal length, scaling comes last in the processing.</p>
<h1><a class="anchor" id="actualorder"></a>
How it is really done</h1>
<p>The actual order perfomed in the Lensfun-calling program will differ from the above list.</p>
<p>Why is this? Understanding this is very important for hacking on Lensfun as well as for using it in your own programs.</p>
<p>When it comes to pixel coordinate transformations, it is very sensful to start with the perfect, rectified image (still empty) and distort its pixel coordinates to the distorted image. This distorted image is the source image (the RAW file), and you can do a simple pixel lookup there, possibly with interpolation. This way, you find all pixel values for your rectified image efficiently and accurately.</p>
<p>However, if you perform pixel lookup this way, things happen the other way round compared to the section before, because you follow the path through the image manipulations the reverse way:</p>
<ol>
<li>
scaling </li>
<li>
perspective correction </li>
<li>
change of projection </li>
<li>
undistortion </li>
<li>
anti-TCA </li>
<li>
devignetting </li>
</ol>
<p>This reverse order is the reason why the formulae for distortion models in <a class="el" href="group__Lens.html#gaa505e04666a189274ba66316697e308e" title="The Lensfun library implements several lens distortion models. This enum lists them. ">lfDistortionModel</a> map the <em>undistorted</em> coordinate to the <em>distorted</em> coordinate. This seems to be wrong at first because we want to undistort after all. But given how undistortion is actually done, it makes sense. The same is true for <a class="el" href="group__Lens.html#ga0b8deda1887fb5543a2038669ed344b4" title="The Lensfun library supports several models for lens lateral chromatic aberrations (also called trans...">lfTCAModel</a>.</p>
<p>Note that in the sequence <em>scaling</em> → <em>perspective correction</em> → <em>change of projection</em> → <em>undistortion</em> → <em>anti-TCA</em>, the resulting coordinates of the previous step are the input coordinates for the respective next step.</p>
<p>In reality, devignetting is performed first nevertheless, because it can be separated from all other operations, by calling <a class="el" href="structlfModifier.html#ab1529c4c56105085d68b58bf469b41c4" title="Image correction step 1: fix image colors. ">lfModifier::ApplyColorModification</a>. Then, you do the coordinate-transforming operations from scaling to anti-TCA. Lensfun can do this in one function call with <a class="el" href="structlfModifier.html#a217fef568888472fbc3d472794f5bb38" title="Apply stage 2 &amp; 3 in one step. ">lfModifier::ApplySubpixelGeometryDistortion</a>. Finally, you do a lookup on the vignetting-corrected RAW data, using the transformed coordinates. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Sun Aug 25 2019 12:00:03 for lensfun by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
