<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>lensfun: lfModifier Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
MathJax.Hub.Config({
    messageStyle: "none"
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.3.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">lensfun
   &#160;<span id="projectnumber">0.3.1.0</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',false,false,'search.php','Search');
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="structlfModifier-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">lfModifier Struct Reference<div class="ingroups"><a class="el" href="group__Correction.html">Image correction</a></div></div>  </div>
</div><!--header-->
<div class="contents">

<p>A modifier object contains optimized data required to rectify a image.  
 <a href="structlfModifier.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="lensfun_8h_source.html">lensfun.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a15fc45849ffb7f7f0f815025d4994ccd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#a15fc45849ffb7f7f0f815025d4994ccd">Initialize</a> (const <a class="el" href="structlfLens.html">lfLens</a> *lens, <a class="el" href="group__Correction.html#gaff4770bc2656179dcfe2da40a25f8148">lfPixelFormat</a> format, float focal, float aperture, float distance, float scale, <a class="el" href="group__Lens.html#gac853bb55ada6a58f12a68f6a1974f764">lfLensType</a> targeom, int flags, bool reverse)</td></tr>
<tr class="memdesc:a15fc45849ffb7f7f0f815025d4994ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize the process of correcting aberrations in a image.  <a href="#a15fc45849ffb7f7f0f815025d4994ccd">More...</a><br /></td></tr>
<tr class="separator:a15fc45849ffb7f7f0f815025d4994ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151fb5b2976d7f0eac935e6d6301051c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#a151fb5b2976d7f0eac935e6d6301051c">Destroy</a> ()</td></tr>
<tr class="memdesc:a151fb5b2976d7f0eac935e6d6301051c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the modifier object.  <a href="#a151fb5b2976d7f0eac935e6d6301051c">More...</a><br /></td></tr>
<tr class="separator:a151fb5b2976d7f0eac935e6d6301051c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d687f9ba8ca71ead2ccb22b0cdc7f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#ac9d687f9ba8ca71ead2ccb22b0cdc7f0">AddCoordCallback</a> (<a class="el" href="group__Correction.html#ga818a017498e0becacdb3c0d445566b9e">lfModifyCoordFunc</a> callback, int priority, void *data, size_t data_size)</td></tr>
<tr class="memdesc:ac9d687f9ba8ca71ead2ccb22b0cdc7f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a user-defined callback to the coordinate correction chain.  <a href="#ac9d687f9ba8ca71ead2ccb22b0cdc7f0">More...</a><br /></td></tr>
<tr class="separator:ac9d687f9ba8ca71ead2ccb22b0cdc7f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a498ad7a647aa056fc4d6bb0546fd0c64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#a498ad7a647aa056fc4d6bb0546fd0c64">AddSubpixelCallback</a> (<a class="el" href="group__Correction.html#ga077f45d25c226258df815a2640a3c504">lfSubpixelCoordFunc</a> callback, int priority, void *data, size_t data_size)</td></tr>
<tr class="memdesc:a498ad7a647aa056fc4d6bb0546fd0c64"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a user-defined callback to the subpixel coordinate rectification chain.  <a href="#a498ad7a647aa056fc4d6bb0546fd0c64">More...</a><br /></td></tr>
<tr class="separator:a498ad7a647aa056fc4d6bb0546fd0c64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29a0eec139e4dbdbefbbb276a5aa909d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#a29a0eec139e4dbdbefbbb276a5aa909d">AddColorCallback</a> (<a class="el" href="group__Correction.html#gad9fd49a4533259a2a148cac4208af681">lfModifyColorFunc</a> callback, int priority, void *data, size_t data_size)</td></tr>
<tr class="memdesc:a29a0eec139e4dbdbefbbb276a5aa909d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a user-defined callback to the color modification chain.  <a href="#a29a0eec139e4dbdbefbbb276a5aa909d">More...</a><br /></td></tr>
<tr class="separator:a29a0eec139e4dbdbefbbb276a5aa909d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe161b1d566e44a09262b430a50efaad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#abe161b1d566e44a09262b430a50efaad">AddSubpixelCallbackTCA</a> (<a class="el" href="structlfLensCalibTCA.html">lfLensCalibTCA</a> &amp;model, bool reverse=false)</td></tr>
<tr class="memdesc:abe161b1d566e44a09262b430a50efaad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the stock TCA correcting callback into the chain.  <a href="#abe161b1d566e44a09262b430a50efaad">More...</a><br /></td></tr>
<tr class="separator:abe161b1d566e44a09262b430a50efaad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53699fb065c16d790159d3620e2bcce"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#ac53699fb065c16d790159d3620e2bcce">AddColorCallbackVignetting</a> (<a class="el" href="structlfLensCalibVignetting.html">lfLensCalibVignetting</a> &amp;model, <a class="el" href="group__Correction.html#gaff4770bc2656179dcfe2da40a25f8148">lfPixelFormat</a> format, bool reverse=false)</td></tr>
<tr class="memdesc:ac53699fb065c16d790159d3620e2bcce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the stock lens vignetting correcting callback into the chain. The vignetting correction callback always has a fixed priority of 250 when rectifying a image or 750 when doing reverse transform.  <a href="#ac53699fb065c16d790159d3620e2bcce">More...</a><br /></td></tr>
<tr class="separator:ac53699fb065c16d790159d3620e2bcce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7667794487035d913d42767cdc063ba6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#a7667794487035d913d42767cdc063ba6">AddCoordCallbackDistortion</a> (<a class="el" href="structlfLensCalibDistortion.html">lfLensCalibDistortion</a> &amp;model, bool reverse=false)</td></tr>
<tr class="memdesc:a7667794487035d913d42767cdc063ba6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the stock lens distortion correcting callback into the chain.  <a href="#a7667794487035d913d42767cdc063ba6">More...</a><br /></td></tr>
<tr class="separator:a7667794487035d913d42767cdc063ba6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a361c472d729bfe1f2d981073eb87d6bd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#a361c472d729bfe1f2d981073eb87d6bd">AddCoordCallbackGeometry</a> (<a class="el" href="group__Lens.html#gac853bb55ada6a58f12a68f6a1974f764">lfLensType</a> from, <a class="el" href="group__Lens.html#gac853bb55ada6a58f12a68f6a1974f764">lfLensType</a> to, float focal)</td></tr>
<tr class="memdesc:a361c472d729bfe1f2d981073eb87d6bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the stock lens geometry rectification callback into the chain.  <a href="#a361c472d729bfe1f2d981073eb87d6bd">More...</a><br /></td></tr>
<tr class="separator:a361c472d729bfe1f2d981073eb87d6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1881133172446fefd2362ae69b6b8008"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#a1881133172446fefd2362ae69b6b8008">AddCoordCallbackScale</a> (float scale, bool reverse=false)</td></tr>
<tr class="memdesc:a1881133172446fefd2362ae69b6b8008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the stock image scaling callback into the chain.  <a href="#a1881133172446fefd2362ae69b6b8008">More...</a><br /></td></tr>
<tr class="separator:a1881133172446fefd2362ae69b6b8008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaaf04bd6a1c32dab998dfc763f98692"><td class="memItemLeft" align="right" valign="top">float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#adaaf04bd6a1c32dab998dfc763f98692">GetAutoScale</a> (bool reverse)</td></tr>
<tr class="memdesc:adaaf04bd6a1c32dab998dfc763f98692"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute the automatic scale factor for the image.  <a href="#adaaf04bd6a1c32dab998dfc763f98692">More...</a><br /></td></tr>
<tr class="separator:adaaf04bd6a1c32dab998dfc763f98692"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ea5562a78c04946fc945237d318c669"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#a6ea5562a78c04946fc945237d318c669">ApplyColorModification</a> (void *pixels, float x, float y, int width, int height, int comp_role, int row_stride) const</td></tr>
<tr class="memdesc:a6ea5562a78c04946fc945237d318c669"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image correction step 1: fix image colors.  <a href="#a6ea5562a78c04946fc945237d318c669">More...</a><br /></td></tr>
<tr class="separator:a6ea5562a78c04946fc945237d318c669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7739fa851629890b9daa04fef9979ab9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#a7739fa851629890b9daa04fef9979ab9">ApplyGeometryDistortion</a> (float xu, float yu, int width, int height, float *res) const</td></tr>
<tr class="memdesc:a7739fa851629890b9daa04fef9979ab9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image correction step 2: apply the transforms on a block of pixel coordinates.  <a href="#a7739fa851629890b9daa04fef9979ab9">More...</a><br /></td></tr>
<tr class="separator:a7739fa851629890b9daa04fef9979ab9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa08d14d032746c06603fb6410ad5ecd6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#aa08d14d032746c06603fb6410ad5ecd6">ApplySubpixelDistortion</a> (float xu, float yu, int width, int height, float *res) const</td></tr>
<tr class="memdesc:aa08d14d032746c06603fb6410ad5ecd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Image correction step 3: apply subpixel distortions.  <a href="#aa08d14d032746c06603fb6410ad5ecd6">More...</a><br /></td></tr>
<tr class="separator:aa08d14d032746c06603fb6410ad5ecd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6726fa1203f35f0850ae18719a759d92"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#a6726fa1203f35f0850ae18719a759d92">ApplySubpixelGeometryDistortion</a> (float xu, float yu, int width, int height, float *res) const</td></tr>
<tr class="memdesc:a6726fa1203f35f0850ae18719a759d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply stage 2 &amp; 3 in one step.  <a href="#a6726fa1203f35f0850ae18719a759d92">More...</a><br /></td></tr>
<tr class="separator:a6726fa1203f35f0850ae18719a759d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ab2505a40e681792e496bcb7289a3cd6e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structlfModifier.html">lfModifier</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structlfModifier.html#ab2505a40e681792e496bcb7289a3cd6e">Create</a> (const <a class="el" href="structlfLens.html">lfLens</a> *lens, float crop, int width, int height)</td></tr>
<tr class="memdesc:ab2505a40e681792e496bcb7289a3cd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a empty image modifier object.  <a href="#ab2505a40e681792e496bcb7289a3cd6e">More...</a><br /></td></tr>
<tr class="separator:ab2505a40e681792e496bcb7289a3cd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A modifier object contains optimized data required to rectify a image. </p>
<p>You can either create an empty modifier object and then enable the required modification functions individually, or you can take a lens object, which contains a set of correction models, and create a modifier object from it.</p>
<p>Normally, you will create an instance with <a class="el" href="structlfModifier.html#ab2505a40e681792e496bcb7289a3cd6e" title="Create a empty image modifier object. ">lfModifier::Create</a> and initilise immediately it with <a class="el" href="structlfModifier.html#a15fc45849ffb7f7f0f815025d4994ccd" title="Initialize the process of correcting aberrations in a image. ">lfModifier::Initialize</a>, passing a valid lens object in both cases. Users of the plain C interface will use <a class="el" href="group__Correction.html#ga8303838db121c2073fa3913ca79a4554">lf_modifier_new()</a> and <a class="el" href="group__Correction.html#gac181e638055efd67ea0953e2badb3e1b">lf_modifier_initialize()</a> instead.</p>
<p>Every image modification has a corresponding inverse function, e.g. the library allows both to correct lens distortions and to simulate lens characteristics.</p>
<p>The normal order of applying a lens correction on a image is: </p><ol>
<li>
Fix lens vignetting </li>
<li>
Fix chromatic aberrations (TCA) </li>
<li>
Fix lens distortion </li>
<li>
Fix lens geometry </li>
<li>
Scale the image </li>
</ol>
<p>This is the theoretical order. But in reality, when using this library, the order is reversed (see <a class="el" href="corrections.html">How the corrections work</a> for an explanation):</p>
<ol>
<li>
Color<ol>
<li>
Fix lens vignetting </li>
</ol>
</li>
<li>
Coordinates<ol>
<li>
Scale the image </li>
<li>
Fix lens geometry </li>
<li>
Fix lens distortion </li>
</ol>
</li>
<li>
Subpixel coordinates<ol>
<li>
Fix chromatic aberrations (TCA) </li>
</ol>
</li>
</ol>
<p>This process is divided into three stages.</p>
<p>In the first stage, the colors of the image pixels are fixed (vignetting). You pass a pointer to your pixel data, and it will be modified in place.</p>
<p>Then, the distortions introduced by the lens are removed (distortion and geometry), and an additional scaling factor is applied if required. This operation requires building new image in a new allocated buffer: you cannot modify the image in place, or bad things will happen.</p>
<p>And finally, in the subpixel distortion stage, application corrects transversal chromatic aberrations. For every target pixel coordinate the modifier will return you three new coordinates: the first will tell you the coordinates of the red component, second of the green, and third of the blue component. This again requires copying the image, but you can use the same buffers as in stage two, just in reverse order.</p>
<p>Of course, you can skip some stages of the process, e.g. if you, for example, don't want to change a fisheye image to a rectilinear you can omit that step.</p>
<p>Obviously, when simulating lens distortions, the modification stages must be applied in reverse order. While the library takes care to reverse the steps which are grouped into a single stage, the application must apply the stages themselves in reverse order.</p>
<p>HOWEVER. Doing it in three stages is not memory efficient, and is prone to error accumulation because you have to interpolate pixels twice - once during stage 2 and once during stage 3. To avoid this, it is sensful to do stages 2 &amp; 3 in one step. In this case the output R,G,B coordinates from stage 2, which treats the colour channels equally, are fed directly into stage 3, which will correct the R,G,B coordinates further. <a class="el" href="structlfModifier.html#a6726fa1203f35f0850ae18719a759d92" title="Apply stage 2 &amp; 3 in one step. ">ApplySubpixelGeometryDistortion()</a> does this in a convenient fashion. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="lenstool_8cpp-example.html#_a16">lenstool.cpp</a>.</dd>
</dl></div><h2 class="groupheader">Member Function Documentation</h2>
<a id="a29a0eec139e4dbdbefbbb276a5aa909d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29a0eec139e4dbdbefbbb276a5aa909d">&#9670;&nbsp;</a></span>AddColorCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lfModifier::AddColorCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Correction.html#gad9fd49a4533259a2a148cac4208af681">lfModifyColorFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a user-defined callback to the color modification chain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback to be called for every strip of pixels. </td></tr>
    <tr><td class="paramname">priority</td><td>Callback priority (0-999). Callbacks are always called in increasing priority order. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to additional user data. A copy of this data is made internally, so client application may do whatever it needs with this data after this call. </td></tr>
    <tr><td class="paramname">data_size</td><td>User data size in bytes. If data size is zero, the data is not copied and instead a verbatim copy of the 'data' parameter is passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac53699fb065c16d790159d3620e2bcce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53699fb065c16d790159d3620e2bcce">&#9670;&nbsp;</a></span>AddColorCallbackVignetting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lfModifier::AddColorCallbackVignetting </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlfLensCalibVignetting.html">lfLensCalibVignetting</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Correction.html#gaff4770bc2656179dcfe2da40a25f8148">lfPixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the stock lens vignetting correcting callback into the chain. The vignetting correction callback always has a fixed priority of 250 when rectifying a image or 750 when doing reverse transform. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>Lens vignetting model data. </td></tr>
    <tr><td class="paramname">format</td><td>Pixel format of your image (bits per pixel component) </td></tr>
    <tr><td class="paramname">reverse</td><td>If true, the reverse model will be applied, e.g. simulate a lens' vignetting on a clean image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if vignetting model is valid and the callback was added to chain. </dd></dl>

</div>
</div>
<a id="ac9d687f9ba8ca71ead2ccb22b0cdc7f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d687f9ba8ca71ead2ccb22b0cdc7f0">&#9670;&nbsp;</a></span>AddCoordCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lfModifier::AddCoordCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Correction.html#ga818a017498e0becacdb3c0d445566b9e">lfModifyCoordFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a user-defined callback to the coordinate correction chain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback to be called for every strip of pixels. </td></tr>
    <tr><td class="paramname">priority</td><td>Callback priority (0-999). Callbacks are always called in increasing priority order. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to additional user data. A copy of this data is made internally, so client application may do whatever it needs with this data after this call. </td></tr>
    <tr><td class="paramname">data_size</td><td>User data size in bytes. If data size is zero, the data is not copied and instead a verbatim copy of the 'data' parameter is passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7667794487035d913d42767cdc063ba6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7667794487035d913d42767cdc063ba6">&#9670;&nbsp;</a></span>AddCoordCallbackDistortion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lfModifier::AddCoordCallbackDistortion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlfLensCalibDistortion.html">lfLensCalibDistortion</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the stock lens distortion correcting callback into the chain. </p>
<p>The distortion correction callback always has a fixed priority of 750 when rectifying a image and 250 on reverse transform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>Lens distortion model data. </td></tr>
    <tr><td class="paramname">reverse</td><td>If true, the reverse model will be applied, e.g. simulate a lens' distortion on a clean image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if distortion model is valid and the callback was added to chain. </dd></dl>

</div>
</div>
<a id="a361c472d729bfe1f2d981073eb87d6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a361c472d729bfe1f2d981073eb87d6bd">&#9670;&nbsp;</a></span>AddCoordCallbackGeometry()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lfModifier::AddCoordCallbackGeometry </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Lens.html#gac853bb55ada6a58f12a68f6a1974f764">lfLensType</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Lens.html#gac853bb55ada6a58f12a68f6a1974f764">lfLensType</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>focal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the stock lens geometry rectification callback into the chain. </p>
<p>The geometry correction callback always has a fixed priority of 500. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>The lens model for source image. </td></tr>
    <tr><td class="paramname">to</td><td>The lens model for target image. </td></tr>
    <tr><td class="paramname">focal</td><td>Lens focal length in mm. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a library has a callback for given from-&gt;to conversion. </dd></dl>

</div>
</div>
<a id="a1881133172446fefd2362ae69b6b8008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1881133172446fefd2362ae69b6b8008">&#9670;&nbsp;</a></span>AddCoordCallbackScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lfModifier::AddCoordCallbackScale </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the stock image scaling callback into the chain. </p>
<p>The scaling callback always has a fixed priority of 100. Note that scaling should be always the first operation to perform no matter if we're doing a forward or reverse transform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scale</td><td>Image scale. If equal to 0.0, the image is automatically scaled so that there won't be any unfilled gaps in the resulting image. Note that all coordinate distortion callbacks must be already added to the stack for this to work correctly! </td></tr>
    <tr><td class="paramname">reverse</td><td>If true, the reverse model will be applied. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if the callback was added to chain. </dd></dl>

</div>
</div>
<a id="a498ad7a647aa056fc4d6bb0546fd0c64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a498ad7a647aa056fc4d6bb0546fd0c64">&#9670;&nbsp;</a></span>AddSubpixelCallback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lfModifier::AddSubpixelCallback </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="group__Correction.html#ga077f45d25c226258df815a2640a3c504">lfSubpixelCoordFunc</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>data_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a user-defined callback to the subpixel coordinate rectification chain. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">callback</td><td>The callback to be called for every strip of pixels. </td></tr>
    <tr><td class="paramname">priority</td><td>Callback priority (0-999). Callbacks are always called in increasing priority order. </td></tr>
    <tr><td class="paramname">data</td><td>A pointer to additional user data. A copy of this data is made internally, so client application may do whatever it needs with this data after this call. </td></tr>
    <tr><td class="paramname">data_size</td><td>User data size in bytes. If data size is zero, the data is not copied and instead a verbatim copy of the 'data' parameter is passed to the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abe161b1d566e44a09262b430a50efaad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe161b1d566e44a09262b430a50efaad">&#9670;&nbsp;</a></span>AddSubpixelCallbackTCA()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lfModifier::AddSubpixelCallbackTCA </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structlfLensCalibTCA.html">lfLensCalibTCA</a> &amp;&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the stock TCA correcting callback into the chain. </p>
<p>The TCA correction callback always has a fixed priority of 500. The behaviour is undefined if you'll add more than one TCA correction callback to a modifier. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>Lens TCA model data. </td></tr>
    <tr><td class="paramname">reverse</td><td>If true, the reverse model will be applied, e.g. simulate a lens' TCA on a clean image. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if TCA model is valid and the callback was added to chain. </dd></dl>

</div>
</div>
<a id="a6ea5562a78c04946fc945237d318c669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ea5562a78c04946fc945237d318c669">&#9670;&nbsp;</a></span>ApplyColorModification()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lfModifier::ApplyColorModification </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pixels</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>comp_role</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row_stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image correction step 1: fix image colors. </p>
<p>This currently is only vignetting transform. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pixels</td><td>This points to image pixels. The actual pixel format depends on both pixel_format and comp_role arguments. The results are stored in place in the same format. Warning: this array should be aligned at least on a 16-byte boundary. </td></tr>
    <tr><td class="paramname">x</td><td>The X coordinate of the corner of the block. </td></tr>
    <tr><td class="paramname">y</td><td>The Y coordinate of the corner of the block. </td></tr>
    <tr><td class="paramname">width</td><td>The width of the image block in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the image block in pixels. </td></tr>
    <tr><td class="paramname">comp_role</td><td>The role of every pixel component. This is a bitfield, made by one of the LF_CR_X macros which defines the roles of every pixel field. For example, <a class="el" href="group__Correction.html#gae3340956c99189894a5efbf2991d8039" title="This macro defines a pixel format consisting of four components. ">LF_CR_4(RED,GREEN,BLUE,UNKNOWN)</a> will define a RGBA (or RGBX) pixel format, and the UNKNOWN field will not be modified. </td></tr>
    <tr><td class="paramname">row_stride</td><td>The size of a image row in bytes. This can be actually different from width * pixel_width as some image formats use funny things like alignments, filler bytes etc. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if return buffer has been altered, false if nothing to do </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="lenstool_8cpp-example.html#a19">lenstool.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a7739fa851629890b9daa04fef9979ab9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7739fa851629890b9daa04fef9979ab9">&#9670;&nbsp;</a></span>ApplyGeometryDistortion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lfModifier::ApplyGeometryDistortion </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image correction step 2: apply the transforms on a block of pixel coordinates. </p>
<p>The undistorted coordinates are computed for every pixel in a rectangular block: \((x_u, y_u), (x_u+1, y_u), \ldots, (x_u + \mathrm{width} - 1, y_u), (x_u, y_u + 1), \ldots, (x_u + \mathrm{width} - 1, y_u + \mathrm{height} - 1)\).</p>
<p>The corrected coordinates are put into the output buffer sequentially, X and Y values.</p>
<p>This routine has been designed to be safe to use in parallel from several threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xu</td><td>The undistorted X coordinate of the start of the block of pixels. </td></tr>
    <tr><td class="paramname">yu</td><td>The undistorted Y coordinate of the start of the block of pixels. </td></tr>
    <tr><td class="paramname">width</td><td>The width of the block in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the block in pixels. </td></tr>
    <tr><td class="paramname">res</td><td>A pointer to an output array which receives the respective X and Y distorted coordinates for every pixel of the block. The size of this array must be at least width*height*2 elements. Warning: this array should be aligned at least on a 16-byte boundary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if return buffer has been filled, false if nothing to do </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="lenstool_8cpp-example.html#a21">lenstool.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="aa08d14d032746c06603fb6410ad5ecd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa08d14d032746c06603fb6410ad5ecd6">&#9670;&nbsp;</a></span>ApplySubpixelDistortion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lfModifier::ApplySubpixelDistortion </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Image correction step 3: apply subpixel distortions. </p>
<p>The undistorted R,G,B coordinates are computed for every pixel in a square block: \((x_u, y_u), (x_u+1, y_u), \ldots, (x_u + \mathrm{width} - 1, y_u), (x_u, y_u + 1), \ldots, (x_u + \mathrm{width} - 1, y_u + \mathrm{height} - 1)\).</p>
<p>Returns the corrected coordinates separately for R/G/B channels The resulting coordinates are put into the output buffer sequentially, X and Y values.</p>
<p>This routine has been designed to be safe to use in parallel from several threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xu</td><td>The undistorted X coordinate of the start of the block of pixels. </td></tr>
    <tr><td class="paramname">yu</td><td>The undistorted Y coordinate of the start of the block of pixels. </td></tr>
    <tr><td class="paramname">width</td><td>The width of the block in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the block in pixels. </td></tr>
    <tr><td class="paramname">res</td><td>A pointer to an output array which receives the respective X and Y distorted coordinates of the red, green and blue channels for every pixel of the block. The size of this array must be at least width*height*2*3 elements. Warning: this array should be aligned at least on a 16-byte boundary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if return buffer has been filled, false if nothing to do </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="lenstool_8cpp-example.html#a18">lenstool.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a6726fa1203f35f0850ae18719a759d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6726fa1203f35f0850ae18719a759d92">&#9670;&nbsp;</a></span>ApplySubpixelGeometryDistortion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool lfModifier::ApplySubpixelGeometryDistortion </td>
          <td>(</td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>xu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>yu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float *&#160;</td>
          <td class="paramname"><em>res</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply stage 2 &amp; 3 in one step. </p>
<p>See the main comment to the <a class="el" href="structlfModifier.html" title="A modifier object contains optimized data required to rectify a image. ">lfModifier</a> class. The undistorted (R, G, B) coordinates are computed for every pixel in a square block: \((x_u, y_u), (x_u+1, y_u), \ldots, (x_u + \mathrm{width} - 1, y_u), (x_u, y_u + 1), \ldots, (x_u + \mathrm{width} - 1, y_u + \mathrm{height} - 1)\).</p>
<p>Returns the corrected coordinates separately for R/G/B channels The resulting coordinates are put into the output buffer sequentially, X and Y values.</p>
<p>This routine has been designed to be safe to use in parallel from several threads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">xu</td><td>The undistorted X coordinate of the start of the block of pixels. </td></tr>
    <tr><td class="paramname">yu</td><td>The undistorted Y coordinate of the start of the block of pixels. </td></tr>
    <tr><td class="paramname">width</td><td>The width of the block in pixels. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the block in pixels. </td></tr>
    <tr><td class="paramname">res</td><td>A pointer to an output array which receives the respective X and Y distorted coordinates for every pixel of the block. The size of this array must be at least width*height*2*3 elements. Warning: this array should be aligned at least on a 16-byte boundary. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if return buffer has been filled, false if nothing to do </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="lenstool_8cpp-example.html#a17">lenstool.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="ab2505a40e681792e496bcb7289a3cd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2505a40e681792e496bcb7289a3cd6e">&#9670;&nbsp;</a></span>Create()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structlfModifier.html">lfModifier</a>* lfModifier::Create </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlfLens.html">lfLens</a> *&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>crop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>width</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>height</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a empty image modifier object. </p>
<p>Before using the returned object you must add the required modifier callbacks (see methods AddXXXCallback below).</p>
<p>You must provide the original image width/height even if you plan to correct just a part of the image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>For all modifications, the crop factor, aspect ratio, and center shift of this lens will be used. </td></tr>
    <tr><td class="paramname">crop</td><td>The crop factor for current camera. The distortion models will take this into account if lens models were measured on a camera with a different crop factor. </td></tr>
    <tr><td class="paramname">width</td><td>The width of the image you want to correct. </td></tr>
    <tr><td class="paramname">height</td><td>The height of the image you want to correct. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A new empty image modifier object. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="lenstool_8cpp-example.html#a37">lenstool.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="a151fb5b2976d7f0eac935e6d6301051c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151fb5b2976d7f0eac935e6d6301051c">&#9670;&nbsp;</a></span>Destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void lfModifier::Destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the modifier object. </p>
<p>This is the only correct way to destroy a <a class="el" href="structlfModifier.html" title="A modifier object contains optimized data required to rectify a image. ">lfModifier</a> object. </p>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="lenstool_8cpp-example.html#a40">lenstool.cpp</a>.</dd>
</dl>
</div>
</div>
<a id="adaaf04bd6a1c32dab998dfc763f98692"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaaf04bd6a1c32dab998dfc763f98692">&#9670;&nbsp;</a></span>GetAutoScale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float lfModifier::GetAutoScale </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute the automatic scale factor for the image. </p>
<p>This expects that all coordinate distortion callbacks are already set up and working. The function will try at its best to find a scale value that will ensure that no pixels with coordinates out of range will get into the resulting image. But since this is an approximative method, the returned scale sometimes is a little less than the optimal scale (e.g. you can still get some black corners with some high-distortion cases). </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">reverse</td><td>If true, the reverse scaling factor is computed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a15fc45849ffb7f7f0f815025d4994ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15fc45849ffb7f7f0f815025d4994ccd">&#9670;&nbsp;</a></span>Initialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int lfModifier::Initialize </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structlfLens.html">lfLens</a> *&#160;</td>
          <td class="paramname"><em>lens</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Correction.html#gaff4770bc2656179dcfe2da40a25f8148">lfPixelFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>focal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>aperture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="group__Lens.html#gac853bb55ada6a58f12a68f6a1974f764">lfLensType</a>&#160;</td>
          <td class="paramname"><em>targeom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize the process of correcting aberrations in a image. </p>
<p>The modifier object will be set up to rectify all aberrations found in the lens description. Make sure the focal length, aperture, and focus distance are correct in order to ensure proper rectification.</p>
<p>Aperture and focus distance are only used for vignetting correction. Because the dependence of vignetting on focus distance is very small, and it is usually not available in EXIF data, you may give an approximative value here. If you really do not know, as a last resort, use "1000" as a default value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lens</td><td>The lens which aberrations you want to correct in a image. It should be the same lens object as the one passed to <a class="el" href="structlfModifier.html#ab2505a40e681792e496bcb7289a3cd6e" title="Create a empty image modifier object. ">lfModifier::Create</a>. </td></tr>
    <tr><td class="paramname">format</td><td>Pixel format of your image (bits per pixel component) </td></tr>
    <tr><td class="paramname">focal</td><td>The focal length in mm at which the image was taken. </td></tr>
    <tr><td class="paramname">aperture</td><td>The aperture (f-number) at which the image was taken. </td></tr>
    <tr><td class="paramname">distance</td><td>The approximative focus distance in meters (distance &gt; 0). </td></tr>
    <tr><td class="paramname">scale</td><td>An additional scale factor to be applied onto the image (1.0 - no scaling; 0.0 - automatic scaling). </td></tr>
    <tr><td class="paramname">targeom</td><td>Target geometry. If LF_MODIFY_GEOMETRY is set in <em>flags</em> and <em>targeom</em> is different from lens-&gt;Type, a geometry conversion will be applied on the image. </td></tr>
    <tr><td class="paramname">flags</td><td>A set of flags (se LF_MODIFY_XXX) telling which distortions you want corrected. A value of LF_MODIFY_ALL orders correction of everything possible (will enable all correction models present in lens description). </td></tr>
    <tr><td class="paramname">reverse</td><td>If this parameter is true, a reverse transform will be prepared. That is, you take a undistorted image at input and convert it so that it will look as if it would be a shot made with <em>lens</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A set of LF_MODIFY_XXX flags in effect. This is the <em>flags</em> argument with dropped bits for operations which are actually no-ops. </dd></dl>
<dl><dt><b>Examples: </b></dt><dd><a class="el" href="lenstool_8cpp-example.html#a38">lenstool.cpp</a>.</dd>
</dl>
</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="lensfun_8h_source.html">lensfun.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 29 2018 12:19:13 for lensfun by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
